# ===

# Write a program reading regular expressions, then constructing NFA using Thompson algorithm, converting NFA into DFA and checking 
# if input strings are generated by this expression (working on DFA). 
# The programs should check if the format of the regular expression given by a user is correct. If the format is incorrect, 
# the error message should be raised.

# Read regular expression from text file or from command line.
# Use the syntax as given on the lecture:
# Closure *
# Positive closure + (optional)
# Or (union) operator |
# To group subexpressions ()
# E.g.: (a | b)* or a | ba*

# ===

# CLASSES

class NFA:
    # Creates simple nfa: q0 --symbol--> q1  
    def __init__(self, starting_state, end_state, symbol) -> None:
        self.starting_state = starting_state
        self.end_state = end_state
        self.transition_table = [[starting_state, end_state, symbol]]   # list[state, tuple(input_symbol, list(transition states))]

    def __str__(self) -> str:
        transitions = "Transition table: \n"
        for transition in self.transition_table:
            transitions += "(" + str(transition[0]) + ") ---" +  str(transition[2]) + "---> (" + str(transition[1]) + ")\n"
        return str("NFA print: \n" + "Starting state:\t" + str(self.starting_state) + "\n" +
                   "End state:\t" + str(self.end_state) + "\n" + 
                   transitions)

class DFA:
    def __init__(self, starting_state = None, end_states = [], transition_table = [], dfa_symbols = []) -> None:
        self.starting_state = starting_state
        self.end_states = end_states
        self.transition_table = transition_table  # list of (state_from, state_to, symbol)
        self.dfa_symbols = dfa_symbols

    def __str__(self) -> str:
        transitions = "Transition table: \n"
        for transition in self.transition_table:
            transitions += "(" + str(transition[0]) + ") ---" +  str(transition[2]) + "---> (" + str(transition[1]) + ")\n"
        return str("DFA print: \n" + "Starting state:\t" + str(self.starting_state) + "\n" +
                   "End states:\t" + str(self.end_states) + "\n" + 
                   transitions)

    def add_transition(self, state_from, state_to, symbol):
        self.transition_table.append((state_from, state_to, symbol))

    def set_start(self, starting_state):
        self.starting_state = starting_state
    
    def set_end(self, end_states):
        self.end_states = end_states

    def run_input(self, input):
        # from_states = [s[0] for s in self.transition_table]
        current_state = self.starting_state
        
        for symbol in input:
            # if symbol not in transition table, reject input
            if symbol not in self.dfa_symbols:
                return False
            # find transition with from-state == current-state
            symbol_transitions = [transition for transition in self.transition_table if transition[2] == symbol]
            match_transition = [transition for transition in symbol_transitions if transition[0] == current_state].pop()
            current_state = match_transition[1]

        if current_state in self.end_states:
            return True
        return False

class ExpresionParser:
    def __init__(self, allowed_symbols, allowed_operators) -> None:
        self.allowed_symbols = allowed_symbols
        self.allowed_operators = allowed_operators
        # precedence (fom highest to lowest)
        self.operator_precedence = {
            '*': 4,
            '?': 3,
            '|': 2,
            '(': 1
        }

    # Check if expression is correct (for now, only symbol correctness, operator syntax check to be implemented)
    def check_expression(self, expression: str) -> None:
        for symbol in expression:
            if symbol not in (self.allowed_symbols + self.allowed_operators):
                raise ValueError("Regular expression contains invalid symbol!")
        return expression

    # function for replacing implied concatenation with operator '?' to make shunting yard easier
    def implied_concatenation(self, expression: str):
        self.check_expression(expression)
        output = ""
        expression_stack = list(expression)
        expression_stack = expression_stack[::-1]   # reverse the stack to pop from front
        symbol = expression_stack.pop()
        output += symbol
        # symbols implying concatenation with neighbor (with all grammar symbols)
        left_req = "*)"
        right_req = "("
        while not len(expression_stack) == 0:
            next_symbol = expression_stack.pop()
            # if symbol in grammar or 
            if symbol in self.allowed_symbols or symbol in left_req:
                # if next symbol in grammar is an operator which imples concatenation
                if next_symbol in self.allowed_symbols:
                    # place ?
                    output += '?'
                # if next symbol is operator which implies concatenation
                elif next_symbol in right_req:
                    # place ?
                    output += '?'
            # place next symbol in output
            output += next_symbol
            symbol = next_symbol

        return output

    # Shunting yard method, turns regular expression to postfix notation
    def shunting_yard(self, expression: str) -> str:
        self.check_expression(expression)
        expression_stack = list(expression)
        expression_stack = expression_stack[::-1]   # reverse the stack to pop from front
        output_queue = []
        operator_stack = []
        while not len(expression_stack) == 0:
            symbol = expression_stack.pop()
            # if operator
            if symbol in self.allowed_operators:
                # if opening parenthesis or no operators on stack, add to operator stack
                if symbol == '(' or len(operator_stack) == 0:
                    operator_stack.append(symbol)
                # if closing parenthesis
                elif symbol == ')':
                    # Search for opening parenthesis in the operator stack, then move on
                    popped_operator = operator_stack.pop() 
                    while not popped_operator == '(':
                        output_queue.append(popped_operator)
                        popped_operator = operator_stack.pop()
                # if symbol is the same operator as last element on stack
                elif symbol == operator_stack[-1]:
                    # move last operator from stack to output and put back symbol in expression
                    output_queue.append(operator_stack.pop())
                    expression_stack.append(symbol)
                # if symbol has higher precedence than last operator on operator stack, add symbol to operator stack
                elif self.operator_precedence[symbol] > self.operator_precedence[operator_stack[-1]]:
                    operator_stack.append(symbol)
                # if symbol has lower precedence
                else:
                    # move the operator with higher precedence from the stack to output and put back symbol
                    output_queue.append(operator_stack.pop())
                    expression_stack.append(symbol)
            # if symbol add to output queue
            else: 
                output_queue.append(symbol)

        # if operators on stack left, pop them to output
        while not len(operator_stack) == 0:
            output_queue.append(operator_stack.pop())

        return output_queue

class Thompson:
    # Returns a closure of NFA
    def closure(nfa: NFA, state_count) -> NFA:
        new_start = state_count + 1
        new_end = state_count + 2

        # Epsilon transitions
        nfa.transition_table.append([new_start, nfa.starting_state, "eps"])     # new start to start
        nfa.transition_table.append([nfa.end_state, new_end, "eps"])            # end to new end
        nfa.transition_table.append([nfa.end_state, nfa.starting_state, "eps"]) # end to start
        nfa.transition_table.append([new_start, new_end, "eps"])                # new start to new end

        # Update start and end
        nfa.starting_state = new_start
        nfa.end_state = new_end

        return nfa

    # Turns two NFAs into OR operation of them
    def union(nfa1: NFA, nfa2: NFA, state_count) -> NFA:
        new_start = state_count + 1
        new_end = state_count + 2

        # Epsilon transitions
        nfa1.transition_table.append([new_start, nfa1.starting_state, "eps"])   # new start to start1
        nfa1.transition_table.append([nfa1.end_state, new_end, "eps"])          # end1 to new end
        nfa2.transition_table.append([new_start, nfa2.starting_state, "eps"])   # new start to start2
        nfa2.transition_table.append([nfa2.end_state, new_end, "eps"])          # end2 to new end

        # Transfer nfa2 transitions to nfa1
        nfa1.transition_table.extend(nfa2.transition_table)

        # Update start and end
        nfa1.starting_state = new_start
        nfa1.end_state = new_end

        return nfa1

    # Concatenates two NFAs
    def concatenate(nfa1: NFA, nfa2: NFA) -> NFA:
        for i in range(len(nfa1.transition_table)):
            if nfa1.transition_table[i][1] == nfa1.end_state:
                nfa1.transition_table[i][1] = nfa2.starting_state
        nfa1.end_state = nfa2.end_state                     # attach nfa1 to end of nfa2
        nfa1.transition_table.extend(nfa2.transition_table) # add nfa2 transitions to nfa1
        return nfa1
    
    # Turns every grammar symbol in postfix expression into an NFA
    def postfix_to_nfa(postfix, parser: ExpresionParser):
        nfa_stack = postfix.copy()
        state_count = 0
        for i in range(len(nfa_stack)):
            if nfa_stack[i] in parser.allowed_symbols:
                nfa_stack[i] = NFA(state_count, state_count+1, nfa_stack[i])
                state_count += 2
        return nfa_stack, state_count

    # Turn postfix regular expression into NFA
    def reg_to_nfa(postfix, parser: ExpresionParser) -> NFA:
        postfix = postfix[::-1]     # reverse the stack to pop from front
        # convert stack to nfa stack
        nfa_stack, state_count = Thompson.postfix_to_nfa(postfix, parser)
        operation_stack = []
        
        # perform operations on postfix nfa stack
        while not len(nfa_stack) == 0:
            object = nfa_stack.pop()
            if object == '*':
                # take one nfa from operation stack and perform closure, then put it back
                nfa_closure = Thompson.closure(operation_stack.pop(), state_count)
                state_count += 2
                operation_stack.append(nfa_closure)
            elif object == '?':
                # take two nfa's from operation stack, concatenate them, then put it back
                nfa2 = operation_stack.pop()
                nfa1 = operation_stack.pop()
                operation_stack.append(Thompson.concatenate(nfa1, nfa2))
            elif object == '|':
                # take two nfa's from operation stack and put their union back
                nfa2 = operation_stack.pop()
                nfa1 = operation_stack.pop()
                operation_stack.append(Thompson.union(nfa1, nfa2, state_count))
                state_count += 2
            else:
                # if nfa, add to operation stack
                operation_stack.append(object)

        return operation_stack.pop()

class Dstate:
    def __init__(self, name = None, nfa_states = []) -> None:
        self.name = name
        self.nfa_states = nfa_states
        self.marked = False

    def __str__(self) -> str:
        return "Print Dstate: \nstate name: " + str(self.name) + "\nnfa states:\t" + str(self.nfa_states) + "\nis marked:\t" + str(self.marked)
    
    def __repr__(self) -> str:
        return str(self.name)
        
    def mark(self):
        self.marked = True

    def set_nfa_states(self, nfa_states):
        self.nfa_states = nfa_states

class SubsetConstruction:
    # returns set of NFA states reachable from given states only by eps-transitions 
    def eps_closure(nfa: NFA, state_set):
        # add to output_transitions transitions with from-states == closure-state from eps_table
        # check if to-states in transitions in output_transitions are from-states in transitions in eps_table
        # if yes move those transitions from eps_table to output_transitions and repeat
        # if no end of eps_closure

        # initialize
        output_set = state_set.copy()
        output_transitions = []
        eps_table = [transition for transition in nfa.transition_table if transition[2] == "eps"]   # only epsilon transitions

        output_transitions = [transition for transition in eps_table if transition[0] in state_set]
        eps_table = [x for x in eps_table if x not in output_transitions]

        # closure loop
        while True:
            # print("eps table: \t", eps_table)
            # print("output t: \t", output_transitions)
            # create a list of every to-state in output_transitions
            to_states = []
            for transition in output_transitions:
                to_states.append(transition[1])
            # add to-states to output_set
            for state in to_states:
                if state not in output_set:
                    output_set.append(state)
            # create a list of all transitions in eps_table which has from-states that can be found in to_states list
            check_list = [transition for transition in eps_table if transition[0] in to_states]
            # print("check list: \t", check_list)
            # if empty, closure complete, return all states
            if len(check_list) == 0:
                # print("output set :", output_set)
                return output_set
            # remove transitions from eps_table that can be found in check_list
            eps_table = [x for x in eps_table if x not in check_list]
            output_transitions.extend(check_list)

    # returns set of NFA states reachable from given Dstate only by symbol-transitions
    def move(nfa: NFA, dstate: Dstate, symbol):
        # transitions only with given symbol input
        symbol_transitions = [transition for transition in nfa.transition_table if transition[2] == symbol]
        output_transitions = [transition for transition in symbol_transitions if transition[0] in dstate.nfa_states]

        output = []
        for transition in output_transitions:
            output.append(transition[1])

        return output

    # converts NFA to DFA
    def nfa_to_dfa(nfa: NFA) -> DFA:
        initial_dstate = Dstate(0, SubsetConstruction.eps_closure(nfa, [nfa.starting_state]))
        dstates = [initial_dstate]
        dtran = []
        # make a list of symbols in given nfa
        dfa_symbols = []
        for transition in nfa.transition_table:
            symbol = transition[2]
            if symbol not in dfa_symbols and not symbol == "eps":
                dfa_symbols.append(transition[2])

        state_count = 1
        unmarked_states = [state for state in dstates if not state.marked]
        while not len(unmarked_states) == 0:
            T_state = unmarked_states.pop()
            T_state.mark()
            # print("For state: " + str(T_state.name))
            # print("with states: " + str(T_state.nfa_states))
            for symbol in dfa_symbols:
                closure_states = SubsetConstruction.eps_closure(nfa, SubsetConstruction.move(nfa, T_state, symbol))
                # print("move(" + str(T_state.name) + ", " + str(symbol) + ") = " + str(SubsetConstruction.move(nfa, T_state, symbol)))
                # print("e-closure(move(" + str(T_state.name) + ", " + str(symbol) + ")) = " + str(closure_states))
                # if state like that doesn't exist dstates, create and add such dstate. If it does U_state = that state
                match_dstate = [state for state in dstates if state.nfa_states == closure_states]
                U_state: Dstate
                if len(match_dstate) == 0:
                    U_state = Dstate(state_count, closure_states)
                    state_count += 1
                    dstates.append(U_state)
                else:
                    U_state = match_dstate.pop()
                # add to transition table
                dtran.append((T_state, U_state, symbol))
                unmarked_states = [state for state in dstates if not state.marked]
        end_states = [state for state in dstates if nfa.end_state in state.nfa_states]
        _dfa = DFA(initial_dstate, end_states, dtran, dfa_symbols)
        return _dfa

# read
debug_mode = True
if not debug_mode:
    user_input = input("read regular expression from file? (y/n) ")
    if user_input == "y":
        f = open("regular_expression.txt", "r")
        user_input = f.read()
        f.close()
    elif user_input == "n":
        user_input = input("provide a regular expression: ")
    else:
        print("incorrect input")
        exit()
else:
    f = open("regular_expression.txt", "r")
    user_input = f.read()
    f.close()

grammar = "0123456789abcdefghijklmnopqrstuvwxyz"        # allowed numbers and lowercases
operators = "*|()?"                                     # allowed operators

parser = ExpresionParser(grammar, operators)
expression: str = parser.check_expression(user_input)   # check expression syntax

expression = parser.implied_concatenation(expression)   # replace implied concatenation with '?' operator
postfix_expression = parser.shunting_yard(expression)   # use shuntin yard method to convert expression to postfix notation

nfa = Thompson.reg_to_nfa(postfix_expression, parser)   # construct NFA using Thompson algorithm

_dfa = SubsetConstruction.nfa_to_dfa(nfa)               # convert NFA to DFA using subset construction algorithm

# check with input
f = open("input.txt", "r")
if _dfa.run_input(f.read()):
    print("match")
f.close()